Object subclass: #OOPObject	instanceVariableNames: 'superclassInstances'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP4'!!OOPObject methodsFor: 'initialize-release' stamp: 'L&M 5/28/2019 13:22'!definingInstance: aSymbol	|st|	st := (self class) classifyInheritedMethod: aSymbol.	((st = 'undefined') or: [st = 'ambiguous'] or: [st = 'inaccessible']) ifTrue: [^ nil].	^ self definingInstanceAux: aSymbol! !!OOPObject methodsFor: 'initialize-release' stamp: 'L&M 5/28/2019 16:15'!definingInstanceAux: aSymbol	|counter|	(self class superclasses isEmpty) ifTrue: [^ nil].	counter := 1.	self class superclasses do: [:parent| (parent parentClass superclass = OOPObject)									ifTrue: [(parent parentClass includesSelector: aSymbol) ifTrue: [^ superclassInstances atWrap: counter]]									ifFalse: [(parent parentClass canUnderstand: aSymbol) ifTrue: [^ superclassInstances atWrap: counter]].									counter := counter + 1].	self class superclasses do: [:parent| |answer| (parent parentClass isKindOf: OOPObject)										ifTrue: [answer := (parent parentClass definingInstanceAux: aSymbol). (answer ~= nil) ifTrue: [^ answer]]].	^ nil! !!OOPObject methodsFor: 'initialize-release' stamp: 'L&M 5/24/2019 16:11'!initialize	^self initializeSupers postInitialize! !!OOPObject methodsFor: 'initialize-release' stamp: 'L&M 5/28/2019 14:36'!initializeSupers	|counter|	superclassInstances := Array new: (self class superclasses size).	counter := 1.	(self class superclasses) do: [:parent | superclassInstances atWrap: counter put: ((parent parentClass) new). counter := counter + 1]! !!OOPObject methodsFor: 'initialize-release' stamp: 'L&M 5/24/2019 16:10'!postInitialize	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OOPObject class	instanceVariableNames: 'superclasses'!!OOPObject class methodsFor: 'class initialization' stamp: 'L&M 5/28/2019 16:13'!classifyInheritedMethod: aSymbol	|answers counter ans ct|	answers := Array new: (self superclasses size).	ct := 1.	(self superclasses) do: [:parent| |st| (parent parentClass isKindOf: OOPObject) ifTrue: [st := (parent parentClass classifyInheritedMethodAux: aSymbol).			(st = 'undefined') ifTrue: [answers atWrap: ct put: 'undefined'].			(st = 'found') ifTrue: [answers atWrap: ct put: (parent inheritanceType)].			(st = 'private') ifTrue: [answers atWrap: ct put: 'inaccessible'].			(st = 'public') ifTrue: [answers atWrap: ct put: (parent inheritanceType)].			(st = 'protected') ifTrue: [(parent inheritanceType = 'private') ifTrue: [answers atWrap: ct put: 'private'] ifFalse: [answers atWrap: ct put: 'protected']].			(st = 'inaccessible') ifTrue: [answers atWrap: ct put: 'inaccessible'].			(st = 'ambiguous') ifTrue: [answers atWrap: ct put: 'ambiguous']]			ifFalse: [(parent parentClass canUnderstand: aSymbol) ifTrue: [answers atWrap: ct put: (parent inheritanceType)]					ifFalse: [answers atWrap: ct put: 'undefined']].			ct := ct + 1].	(answers includes: 'ambiguous') ifTrue: [^'ambiguous'].	counter := 0.	(answers do: [:st | (st ~= 'undefined') ifTrue: [counter := counter + 1]]).	(counter > 1) ifTrue: [^'ambiguous'].	(counter = 0) ifTrue: [^'undefined'].	ans := answers select: [:st| st ~= 'undefined'].	^(ans atWrap: 1)! !!OOPObject class methodsFor: 'class initialization' stamp: 'L&M 5/28/2019 19:12'!classifyInheritedMethodAux: aSymbol	(self superclasses isEmpty)		ifTrue: [(self superclass = OOPObject)			ifTrue: [(self includesSelector: aSymbol)					ifTrue: [^'found']					ifFalse: [^'undefined']]			ifFalse:[(self canUnderstand: aSymbol)					ifTrue: [^'found']					ifFalse: [^'undefined']]]		ifFalse: [|answers counter ans ct| answers := Array new: (self superclasses size). ct := 1.			self superclasses do:			[:parent | (parent parentClass isKindOf: OOPObject) ifTrue: [|st| st := (parent parentClass classifyInheritedMethodAux: aSymbol).			(st = 'undefined') ifTrue: [answers atWrap: ct put: 'undefined'].			(st = 'found') ifTrue: [answers atWrap: ct put: (parent inheritanceType)].			(st = 'private') ifTrue: [answers atWrap: ct put: 'inaccessible'].			(st = 'public') ifTrue: [answers atWrap: ct put: (parent inheritanceType)].			(st = 'protected') ifTrue: [(parent inheritanceType = 'private') ifTrue: [answers atWrap: ct put: 'private'] ifFalse: [answers atWrap: ct put: 'protected']].			(st = 'inaccessible') ifTrue: [answers atWrap: ct put: 'inaccessible'].			(st = 'ambiguous') ifTrue: [answers atWrap: ct put: 'ambiguous']]			ifFalse: [(parent parentClass canUnderstand: aSymbol) ifTrue: [answers atWrap: ct put: (parent inheritanceType)]				ifFalse: [answers atWrap: ct put: 'undefined']].			ct := ct + 1].			(answers includes: 'ambiguous') ifTrue: [^'ambiguous'].			counter := 0.			(answers do: [:st | (st ~= 'undefined') ifTrue: [counter := counter + 1]]).			(counter > 1) ifTrue: [^'ambiguous'].			ans := answers select: [:st| st ~= 'undefined'].			(self superclass = OOPObject) ifTrue: [(self includesSelector: aSymbol) ifTrue: [^'found'] ifFalse: [(ans size = 0) ifTrue: [^'undefined'] ifFalse: [^(ans atWrap: 1)]]]										ifFalse: [(self canUnderstand: aSymbol) ifTrue: [^'found'] ifFalse: [(ans size = 0) ifTrue: [^'undefined'] ifFalse: [^(ans atWrap: 1)]]]].! !!OOPObject class methodsFor: 'class initialization' stamp: 'L&M 5/29/2019 09:35'!multInheritsFrom: aClass	(self superclasses isEmpty)		ifTrue: [^false].	(self superclasses) do: [:m | (m parentClass == aClass)		ifTrue: [^true]].	(self superclasses) do: [:m | (m parentClass isKindOf: OOPObject)									ifTrue: [((m parentClass) multInheritsFrom: aClass) ifTrue: [^true]]									ifFalse: [((m parentClass) isKindOf: aClass) ifTrue: [^true]]].	^false.! !!OOPObject class methodsFor: 'class initialization' stamp: 'L&M 5/24/2019 15:48'!subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryName	^ self subclass: aSubclassName parentClasses: (Array new)	instanceVariableNames: instVarNames classVariableNames: classVarNames	poolDictionaries: poolDictionaries category: aCategoryName! !!OOPObject class methodsFor: 'class initialization' stamp: 'L&M 5/28/2019 14:41'!subclass: aSubclassName parentClasses: anArray instanceVariableNames:instVarNames classVariableNames: classVarNames poolDictionaries:poolDictionaries category: aCategoryName	| cl ar counter|	cl := (ClassBuilder new)		superclass: OOPObject		subclass: aSubclassName		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictionaries		category: aCategoryName.	 	(self ~~ OOPObject)		ifTrue: [|parent| ar := Array new: ((anArray size) + 1). parent := OOPParent new. parent parentClass: self.			parent inheritanceType: 'public'. ar atWrap: 1 put: parent. counter := 2]		ifFalse: [ar := Array new: (anArray size). counter := 1].	anArray do: [:element| ar atWrap: counter put: element. counter := counter + 1].	cl instVarNamed: 'superclasses' put: ar.	^ cl	! !!OOPObject class methodsFor: 'class initialization' stamp: 'L&M 5/24/2019 15:16'!superclasses	^superclasses! !!OOPObject class methodsFor: 'class initialization' stamp: 'L&M 5/24/2019 16:14'!throwSender: senderName fails: methodName inClass: receiverName because: reason	| str |	str := senderName, ' cannot send ',methodName asString,' to ',receiverName,' because: '	,reason.	AssertionFailure signal: str.! !Object subclass: #OOPParent	instanceVariableNames: 'parentClass inheritanceType'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP4'!!OOPParent methodsFor: 'initialize-release' stamp: 'L&M 5/24/2019 14:42'!inheritanceType	^ inheritanceType! !!OOPParent methodsFor: 'initialize-release' stamp: 'L&M 5/24/2019 14:44'!inheritanceType: aString	inheritanceType := aString! !!OOPParent methodsFor: 'initialize-release' stamp: 'L&M 5/28/2019 18:02'!initialize	parentClass := Object class.	inheritanceType := 'public'! !!OOPParent methodsFor: 'initialize-release' stamp: 'L&M 5/24/2019 14:42'!parentClass	^ parentClass! !!OOPParent methodsFor: 'initialize-release' stamp: 'L&M 5/24/2019 14:43'!parentClass: aClass	parentClass := aClass! !