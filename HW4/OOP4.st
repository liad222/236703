Object subclass: #OOPObject	instanceVariableNames: 'superclassInstances'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP4'!!OOPObject methodsFor: 'initialize-release' stamp: 'L&M 6/11/2019 12:58'!definingInstance: aSymbol	"Return the instance of the parent class that recognizes the method aSymbol"	|st|	st := (self class) classifyInheritedMethod: aSymbol.	"If the method is undefined, ambiguous or inaccessible in the current class, return nil"	((st = 'undefined') or: [st = 'ambiguous'] or: [st = 'inaccessible']) ifTrue: [^ nil].	"Otherwise, use the aux method definingInstanceAux"	^ self definingInstanceAux: aSymbol! !!OOPObject methodsFor: 'initialize-release' stamp: 'L&M 6/11/2019 13:07'!definingInstanceAux: aSymbol	"An aux method for the instance method definingInstance"	|counter|	"If there are no parents via multiple inheritance - this is the base of the recursion"	(self class superclasses isEmpty) ifTrue: [^ nil].	counter := 1.	"If there are parents via multiple inheritnace, check for each one if they recognize aSymbol"	self class superclasses do: [:parent| (parent parentClass superclass == OOPObject)									"If the parent inherits directly from OOPObject, we should only check methods defined in the parent class. If defined - return the matching instance of the parent 									class."									ifTrue: [(parent parentClass includesSelector: aSymbol) ifTrue: [^ superclassInstances atWrap: counter]]									"If the parent doesn't inherit from OOPObject, we should check all the methods recognized in the parent class. If recognized - return the matching instance of 									the parent class."									ifFalse: [(parent parentClass canUnderstand: aSymbol) ifTrue: [^ superclassInstances atWrap: counter]].									counter := counter + 1].							"If there are parents via multiple inheritance, apply the aux method recursively on each parent instance - only if the inherit (directly or indirectly) from OOPObject"	superclassInstances do: [:parentInst| |answer| (parentInst isKindOf: OOPObject)										ifTrue: [answer := (parentInst definingInstanceAux: aSymbol).											"If a parent regocnized the method, return the matching instance"											(answer ~= nil) ifTrue: [^ answer]]].	"If no ancestor recognized the method, return nil"	^ nil! !!OOPObject methodsFor: 'initialize-release' stamp: 'L&M 6/11/2019 15:27'!doesNotUnderstand: aMessage	"Called when an object doesn't understand aMessage. Try to invoke the message via the multiple inheritance system. If not recognized or if not able to invoke - throw a matching exception"	|sender method st args|	"Find the class that sent the message"	sender := thisContext client class.	method := aMessage selector.	args := aMessage arguments.	"Check if the method is recognized via multiple inheritance, and if so with which access specifier"	st := self class classifyInheritedMethod: method.	"If the method is public in the receiver class, then it can always be invoked - send aMessage with it's arguments to the right instance as dictated by definingInstance"	(st = 'public') ifTrue: [(self definingInstance: method) perform: method withArguments: args].	"If the method is private in the receiver class, then it can be invoked only by the same class"	(st = 'private') ifTrue: [(self class == sender)				"If it is the same class, send aMessage with it's arguments to the right instance as dictated by definingInstance"				ifTrue: [(self definingInstance: method) perform: method withArguments: args]				"If not, throw a matching exception"				ifFalse: [OOPObject throwSender: sender name fails: method inClass: self class name because: st]].	"If the method is protected in the receiver class, then it can be invoked only by the same class of a class derived from it (via direct or multiple inheritance)"	(st = 'protected') ifTrue: [((self class == sender) or: [(sender isKindOf: OOPObject class) and: [sender multInheritsFrom: self class]]							or: [(sender inheritsFrom: self class)])							"If this is the case, send aMessage with it's arguments to the right instance as dictated by definingInstance"							ifTrue: [(self definingInstance: method) perform: method withArguments: args]							"If not, throw a matching exception"							ifFalse: [OOPObject throwSender: sender name fails: method inClass: self class name because: st]].	"If the method is undefined, ambiguous or inaccessible - throw a matching exception"	((st = 'undefined') or: [st = 'ambiguous'] or: [st = 'inaccessible'])		ifTrue: [OOPObject throwSender: sender name fails: method inClass: self class name because: st].! !!OOPObject methodsFor: 'initialize-release' stamp: 'L&M 6/11/2019 12:15'!initialize	"Initialize a new OOPObject by initializing all superclasses instances and any other initialization operations required"	^self initializeSupers postInitialize! !!OOPObject methodsFor: 'initialize-release' stamp: 'L&M 6/11/2019 12:15'!initializeSupers	"Initialize an Array with all superclasses instances - in the order they are stored in the superclasses array"	|counter|	superclassInstances := Array new: (self class superclasses size).	counter := 1.	(self class superclasses) do: [:parent | superclassInstances atWrap: counter put: ((parent parentClass) new). counter := counter + 1]! !!OOPObject methodsFor: 'initialize-release' stamp: 'L&M 6/11/2019 12:04'!postInitialize	"A default method allowing extra initialization operations"	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OOPObject class	instanceVariableNames: 'superclasses'!!OOPObject class methodsFor: 'class initialization' stamp: 'L&M 6/11/2019 12:41'!classifyInheritedMethod: aSymbol	"Check what is the access specifier of the method aSymbol in the current class"	|answers counter ans ct|	"For every parent in superclasses, check what is it's access specifier for aSymbol"	answers := Array new: (self superclasses size).	ct := 1.	(self superclasses) do: [:parent| |st |  (parent parentClass isKindOf: OOPObject class)			"If the parent inherits from OOPObject, we can use the aux method classifyInheritedMethodAux"			ifTrue: [st := (parent parentClass classifyInheritedMethodAux: aSymbol).			"If the method is undefined in the parent, it is undefined in the child"			(st = 'undefined') ifTrue: [answers atWrap: ct put: 'undefined'].			"If the method is defined it the parent, it is recognized in the child with an access specifier matching that parent's inheritance type"			(st = 'found') ifTrue: [answers atWrap: ct put: (parent inheritanceType)].			"If the methid is private in the parent, it is inaccessible from any other class, including the child"			(st = 'private') ifTrue: [answers atWrap: ct put: 'inaccessible'].			"If the method is public in the parent, it is recognized in the child with an access specifier matching that parent's inheritance type"			(st = 'public') ifTrue: [answers atWrap: ct put: (parent inheritanceType)].			"If the method is protected in the parent and the inheriance type is private, then the method is private in the child. In not, it is protected in the child"			(st = 'protected') ifTrue: [(parent inheritanceType = 'private') ifTrue: [answers atWrap: ct put: 'private'] ifFalse: [answers atWrap: ct put: 'protected']].			"If the method is inaccessible in the parent, it is inaccessible in the child"			(st = 'inaccessible') ifTrue: [answers atWrap: ct put: 'inaccessible'].			"If the method is ambiguous in the parent, it is ambiguous in the child"			(st = 'ambiguous') ifTrue: [answers atWrap: ct put: 'ambiguous']]			"If the parent doesn't inherit from OOPObject, we use the direct inheritance version - canUnderstand. If the method is recognized it the parent, it is recognized in the child with an 			access specifier matching that parent's inheritance type. Otherwise it is undefined in the child."			ifFalse: [(parent parentClass canUnderstand: aSymbol)				ifTrue: [answers atWrap: ct put: (parent inheritanceType)]				ifFalse: [answers atWrap: ct put: 'undefined']].			ct := ct + 1].	"If one parent answered ambiguous - the method is ambiguous"	(answers includes: 'ambiguous') ifTrue: [^'ambiguous'].	counter := 0.	(answers do: [:st | (st ~= 'undefined') ifTrue: [counter := counter + 1]]).	"If more than one parent recognizes the method - it is ambiguous"	(counter > 1) ifTrue: [^'ambiguous'].	"If no parent recognizes the method - it is undefined"	(counter = 0) ifTrue: [^'undefined'].	"If exactly one parent recognizes the method - the method is recognized in the child with the matching access specifier"	ans := answers select: [:st| st ~= 'undefined'].	^(ans atWrap: 1)! !!OOPObject class methodsFor: 'class initialization' stamp: 'L&M 6/11/2019 12:56'!classifyInheritedMethodAux: aSymbol	"An aux method for the class method classifyInheritedMethod"	(self superclasses isEmpty)		"If there are no parents via multiple inheritance - this is the base of the recursion"		ifTrue: [(self superclass = OOPObject)			"If the current class inherits directly from OOPObject, we should only check methods defined in the current class"			ifTrue: [(self includesSelector: aSymbol)					ifTrue: [^'found']					ifFalse: [^'undefined']]			"If the current class doesn't inherit from OOPObject, we should check all the methods recognized in the current class"			ifFalse:[(self canUnderstand: aSymbol)					ifTrue: [^'found']					ifFalse: [^'undefined']]]		"If there are parents via multiple inheritance, apply the aux method recursively on each parent"		ifFalse: [|answers counter ans ct| answers := Array new: (self superclasses size). ct := 1.			self superclasses do:			[:parent | (parent parentClass isKindOf: OOPObject class)			"If the parent inherits from OOPObject, we can use the aux method"			ifTrue: [|st| st := (parent parentClass classifyInheritedMethodAux: aSymbol).			"If the method is undefined in the parent, it is undefined in the child"			(st = 'undefined') ifTrue: [answers atWrap: ct put: 'undefined'].			"If the method is defined it the parent, it is recognized in the child with an access specifier matching that parent's inheritance type"			(st = 'found') ifTrue: [answers atWrap: ct put: (parent inheritanceType)].			"If the methid is private in the parent, it is inaccessible from any other class, including the child"			(st = 'private') ifTrue: [answers atWrap: ct put: 'inaccessible'].			"If the method is public in the parent, it is recognized in the child with an access specifier matching that parent's inheritance type"			(st = 'public') ifTrue: [answers atWrap: ct put: (parent inheritanceType)].			"If the method is protected in the parent and the inheriance type is private, then the method is private in the child. In not, it is protected in the child"			(st = 'protected') ifTrue: [(parent inheritanceType = 'private') ifTrue: [answers atWrap: ct put: 'private'] ifFalse: [answers atWrap: ct put: 'protected']].			"If the method is inaccessible in the parent, it is inaccessible in the child"			(st = 'inaccessible') ifTrue: [answers atWrap: ct put: 'inaccessible'].			"If the method is ambiguous in the parent, it is ambiguous in the child"			(st = 'ambiguous') ifTrue: [answers atWrap: ct put: 'ambiguous']]			"If the parent doesn't inherit from OOPObject, we use the direct inheritance version - canUnderstand. If the method is recognized it the parent, it is recognized in the child with an 			access specifier matching that parent's inheritance type. Otherwise it is undefined in the child."			ifFalse: [(parent parentClass canUnderstand: aSymbol) ifTrue: [answers atWrap: ct put: (parent inheritanceType)]				ifFalse: [answers atWrap: ct put: 'undefined']].			ct := ct + 1].			"If one parent answered ambiguous - the method is ambiguous"			(answers includes: 'ambiguous') ifTrue: [^'ambiguous'].			counter := 0.			(answers do: [:st | (st ~= 'undefined') ifTrue: [counter := counter + 1]]).			"If more than one parent recognizes the method - it is ambiguous"			(counter > 1) ifTrue: [^'ambiguous'].			ans := answers select: [:st| st ~= 'undefined'].			(self superclass = OOPObject)				"If the current class inherits directly from OOPObject, we should only check methods defined in the current class"				ifTrue: [(self includesSelector: aSymbol)					"If the method is defined in the current class"					ifTrue: [^'found']					ifFalse: [(ans size = 0)						"If no parent recognizes the method - it is undefined"						ifTrue: [^'undefined']						"If exactly one parent recognizes the method - the method is recognized in the child with the matching access specifier"						ifFalse: [^(ans atWrap: 1)]]]				"If the current class doesn't inherit from OOPObject, we should check all the methods recognized in the current class"				ifFalse: [(self canUnderstand: aSymbol)					"If the method is recognized in the current class"					ifTrue: [^'found']					ifFalse: [(ans size = 0)						"If no parent recognizes the method - it is undefined"						ifTrue: [^'undefined']						"If exactly one parent recognizes the method - the method is recognized in the child with the matching access specifier"						ifFalse: [^(ans atWrap: 1)]]]].! !!OOPObject class methodsFor: 'class initialization' stamp: 'L&M 6/11/2019 12:15'!multInheritsFrom: aClass	"Returns true if self is a class that inherits (directly or indirectly, via multiple inheritance) from aClass"	(self superclasses isEmpty)		ifTrue: [^false].	(self superclasses) do: [:m | (m parentClass == aClass)		ifTrue: [^true]].	(self superclasses) do: [:m | (m parentClass isKindOf: OOPObject class)									"If the parent inherits from OOPObject, use the multiple inheritance version - multInheritsFrom"									ifTrue: [((m parentClass) multInheritsFrom: aClass) ifTrue: [^true]]									"Else, use the direct inheritance version - isKindOf"									ifFalse: [((m parentClass) isKindOf: aClass class) ifTrue: [^true]]].	^false.! !!OOPObject class methodsFor: 'class initialization' stamp: 'L&M 6/11/2019 12:12'!subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryName	"Create a new subclass with the name aSubclassName, that inherits directly from OOPObject and has no other parent classes via multiple inheritance"	^ self subclass: aSubclassName parentClasses: (Array new)	instanceVariableNames: instVarNames classVariableNames: classVarNames	poolDictionaries: poolDictionaries category: aCategoryName! !!OOPObject class methodsFor: 'class initialization' stamp: 'L&M 6/11/2019 12:11'!subclass: aSubclassName parentClasses: anArray instanceVariableNames:instVarNames classVariableNames: classVarNames poolDictionaries:poolDictionaries category: aCategoryName	"Create a new subclass with the name aSubclassName, that inherits directly from OOPObject and indirectly from the parent classes in anArray (via multiple inheritance). All 	other parameters are as usual for creating a subclass."	| cl ar counter|	cl := (ClassBuilder new)		superclass: OOPObject		subclass: aSubclassName		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictionaries		category: aCategoryName.	 	(self ~~ OOPObject)		"If the new subclass inherits directly from a class that isn't OOPObject, this parent class becomes the first superclass in the array"		ifTrue: [|parent| ar := Array new: ((anArray size) + 1). parent := OOPParent new. parent parentClass: self.			parent inheritanceType: 'public'. ar atWrap: 1 put: parent. counter := 2]		ifFalse: [ar := Array new: (anArray size). counter := 1].	anArray do: [:element| ar atWrap: counter put: element. counter := counter + 1].	cl instVarNamed: 'superclasses' put: ar.	^ cl	! !!OOPObject class methodsFor: 'class initialization' stamp: 'L&M 6/11/2019 12:05'!superclasses	"Return the superclasses array of the OOPObject"	^superclasses! !!OOPObject class methodsFor: 'class initialization' stamp: 'L&M 5/24/2019 16:14'!throwSender: senderName fails: methodName inClass: receiverName because: reason	| str |	str := senderName, ' cannot send ',methodName asString,' to ',receiverName,' because: '	,reason.	AssertionFailure signal: str.! !Object subclass: #OOPParent	instanceVariableNames: 'parentClass inheritanceType'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP4'!!OOPParent methodsFor: 'initialize-release' stamp: 'L&M 6/11/2019 11:56'!inheritanceType	"Returns the inheritance type of the OOPParent: public, protected or private"	^ inheritanceType! !!OOPParent methodsFor: 'initialize-release' stamp: 'L&M 6/11/2019 11:58'!inheritanceType: aString	"Changes the inheritance type of the OOPParent to aString"	inheritanceType := aString! !!OOPParent methodsFor: 'initialize-release' stamp: 'L&M 6/11/2019 12:00'!initialize	"Initialize a new OOPParent with class Object and inheritance type public"	parentClass := Object class.	inheritanceType := 'public'! !!OOPParent methodsFor: 'initialize-release' stamp: 'L&M 6/11/2019 11:57'!parentClass	"Returns the class object of the OOPParent"	^ parentClass! !!OOPParent methodsFor: 'initialize-release' stamp: 'L&M 6/11/2019 11:58'!parentClass: aClass	"Changes the class object of OOPParent to aClass"	parentClass := aClass! !